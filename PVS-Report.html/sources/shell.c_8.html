<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>shell.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3">#include &lt;colors.h&gt;</a>
<a name="ln4">#include &lt;userio.h&gt;</a>
<a name="ln5">#include &lt;usyscalls.h&gt;</a>
<a name="ln6">#include &lt;colors.h&gt;</a>
<a name="ln7">#include &lt;sounds.h&gt;</a>
<a name="ln8">#include &lt;pong.h&gt;</a>
<a name="ln9">#include &lt;shell.h&gt;</a>
<a name="ln10">#include &lt;types.h&gt;</a>
<a name="ln11">#include &lt;stddef.h&gt;</a>
<a name="ln12">#include &lt;processLib.h&gt;</a>
<a name="ln13">#include &lt;uStrings.h&gt;</a>
<a name="ln14">#include &lt;shellFunc.h&gt;</a>
<a name="ln15">#include &lt;uSync.h&gt;</a>
<a name="ln16">#include &lt;test_print.h&gt;</a>
<a name="ln17">#include &lt;test_sem.h&gt;</a>
<a name="ln18">#include &lt;test_pipe.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">//</a>
<a name="ln21">// Necesarry functions declarations</a>
<a name="ln22">//</a>
<a name="ln23"> </a>
<a name="ln24">static void parseInput(char *input, ParsedCommand *out);</a>
<a name="ln25">static void (*getFn(const char *cmd))(uint8_t, char **);</a>
<a name="ln26">static int countArgs(char **argv);</a>
<a name="ln27">void shell();</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">//</a>
<a name="ln31">// Structures to map commands to functions</a>
<a name="ln32">//</a>
<a name="ln33"> </a>
<a name="ln34">static void  (*instructionFunctions[])(uint8_t, char **) = {</a>
<a name="ln35">	help,</a>
<a name="ln36">	time,</a>
<a name="ln37">	date,</a>
<a name="ln38">	registers, </a>
<a name="ln39">	fillregs, </a>
<a name="ln40">	div0, </a>
<a name="ln41">	invalidop, </a>
<a name="ln42">	pong, </a>
<a name="ln43">	clear,</a>
<a name="ln44">	hello,</a>
<a name="ln45">	testprint,</a>
<a name="ln46">	testsem,</a>
<a name="ln47">	testpipe,</a>
<a name="ln48">	testpriority,</a>
<a name="ln49">	NULL};</a>
<a name="ln50"> </a>
<a name="ln51">static char *commandsNames[] = {&quot;help&quot;, &quot;time&quot;, &quot;date&quot;, &quot;registers&quot;, &quot;fillregs&quot;, &quot;div0&quot;, &quot;invalidop&quot;, &quot;pong&quot;, &quot;clear&quot;, &quot;hello&quot;, &quot;testprint&quot;, &quot;testsem&quot;, &quot;testpipe&quot;, &quot;testpriority&quot;, 0};</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">//</a>
<a name="ln55">// Shell implentation variables</a>
<a name="ln56">//</a>
<a name="ln57"> </a>
<a name="ln58">static pid_t fgProccess=0;</a>
<a name="ln59">static int hasToWait = 1;</a>
<a name="ln60">static int pipeCounter=0;</a>
<a name="ln61"> </a>
<a name="ln62">//</a>
<a name="ln63">// Shell implementation</a>
<a name="ln64">//</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">pid_t launchShell(){</a>
<a name="ln68">	char* argv[] = {&quot;shell&quot;};</a>
<a name="ln69">	return  createProcess((void*) shell, 1, 0, argv);</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">void shell() {</a>
<a name="ln73">    printColor(&quot;Welcome to HomerOS. Type \&quot;help\&quot; for command list\n&quot;, ORANGE);</a>
<a name="ln74">	printColor(&quot;\nHomerOS: $&gt; &quot;, GREEN);</a>
<a name="ln75"> </a>
<a name="ln76">	int count = 0;	</a>
<a name="ln77">	char buffer[1024] = {0};</a>
<a name="ln78">	char oldBuffer[1024] = {0};</a>
<a name="ln79">	char flag = 0; // Used for up arrow</a>
<a name="ln80">	while(1) {</a>
<a name="ln81">		unsigned char c = getChar();</a>
<a name="ln82">		if (c == '\n') {</a>
<a name="ln83">			buffer[count] = 0;</a>
<a name="ln84">			analizeBuffer(buffer, count);</a>
<a name="ln85">			printColor(&quot;\nHomerOS: $&gt; &quot;, GREEN);</a>
<a name="ln86">			strcpy(oldBuffer, buffer);</a>
<a name="ln87">			flag = 1;</a>
<a name="ln88">			count = 0;</a>
<a name="ln89">		} else if (c == '\b') {</a>
<a name="ln90">			if (count &gt; 0) {</a>
<a name="ln91">				printChar(c);</a>
<a name="ln92">				count--;</a>
<a name="ln93">			}</a>
<a name="ln94">		} else if (c == '\t') {</a>
<a name="ln95">			// analize count letters of the buffer and see if match with any command, if so, complete the command</a>
<a name="ln96">			int i = 0;</a>
<a name="ln97">			while (i &lt; COMMANDS_QUANTITY &amp;&amp; !strncmp(buffer, commandsNames[i], count)) {</a>
<a name="ln98">				i++;</a>
<a name="ln99">			}</a>
<a name="ln100">			if (i &lt; COMMANDS_QUANTITY) {</a>
<a name="ln101">				while (commandsNames[i][count] != 0) {</a>
<a name="ln102">					printChar(commandsNames[i][count]);</a>
<a name="ln103">					buffer[count] = commandsNames[i][count];</a>
<a name="ln104">					count++;</a>
<a name="ln105">				}</a>
<a name="ln106">			}</a>
<a name="ln107">		} else if (c == 17 &amp;&amp; flag) {</a>
<a name="ln108">			// up arrow</a>
<a name="ln109">			while (count &gt; 0) {</a>
<a name="ln110">				printChar('\b');</a>
<a name="ln111">				count--;</a>
<a name="ln112">			}</a>
<a name="ln113">			strcpy(buffer, oldBuffer);</a>
<a name="ln114">			count = strlen(buffer);</a>
<a name="ln115">			print(buffer);</a>
<a name="ln116">			flag = 0;</a>
<a name="ln117">		} else if (c == 20 &amp;&amp; !flag) {</a>
<a name="ln118">			// down arrow</a>
<a name="ln119">			while (count &gt; 0) {</a>
<a name="ln120">				printChar('\b');</a>
<a name="ln121">				count--;</a>
<a name="ln122">			}</a>
<a name="ln123">			flag = 1;</a>
<a name="ln124">		} else if (c &gt; 20 &amp;&amp; c &lt; 127) {</a>
<a name="ln125">			printChar(c);</a>
<a name="ln126">			buffer[count++] = c;</a>
<a name="ln127">			buffer[count] = 0;</a>
<a name="ln128">		}</a>
<a name="ln129">	}</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">/* Deprecated</a>
<a name="ln134">int commandMatch(char * str1, char * command, int count) {</a>
<a name="ln135">	int i = 0;</a>
<a name="ln136">	if (count != strlen(command))</a>
<a name="ln137">		return 0;</a>
<a name="ln138">	while (str1[i] != 0 &amp;&amp; command[i] != 0 &amp;&amp; str1[i] == command[i] &amp;&amp; i &lt; count) {</a>
<a name="ln139">		i++;</a>
<a name="ln140">	}</a>
<a name="ln141">	return str1[i] == command[i];</a>
<a name="ln142">}</a>
<a name="ln143">*/</a>
<a name="ln144"> </a>
<a name="ln145">void analizeBuffer(char * buffer, int count) {</a>
<a name="ln146">	if (count &lt;= 0)</a>
<a name="ln147">		return;</a>
<a name="ln148">	ParsedCommand parsed= {0};</a>
<a name="ln149">	parseInput(buffer, &amp;parsed);</a>
<a name="ln150"> </a>
<a name="ln151">	     </a>
<a name="ln152">	hasToWait= !parsed.isBackground;</a>
<a name="ln153"> </a>
<a name="ln154">	</a>
<a name="ln155">	</a>
<a name="ln156">	if (parsed.hasPipe) { //TODO: descomentar cuando esten las pipes (y probarlo(Si falla y no tienen ganas de arreglarlo, diganle al chile))</a>
<a name="ln157">		char* name;</a>
<a name="ln158">		unsigned_num_to_str(pipeCounter,0,name);</a>
<a name="ln159">		uint8_t anonPipe=sys_pipe_open(name);</a>
<a name="ln160">		pipeCounter++;</a>
<a name="ln161">		</a>
<a name="ln162">		</a>
<a name="ln163">		void (*fn1)(uint8_t, char **) = getFn(parsed.cmd1);</a>
<a name="ln164">		void (*fn2)(uint8_t, char **) = getFn(parsed.cmd2);</a>
<a name="ln165"> </a>
<a name="ln166">		if (!fn1 || !fn2) {</a>
<a name="ln167">			printf(&quot;Unknown command in pipe: %s | %s\n&quot;, parsed.cmd1, parsed.cmd2);</a>
<a name="ln168">			return;</a>
<a name="ln169">		}</a>
<a name="ln170"> </a>
<a name="ln171">		pid_t p1 = sys_launch_process(fn1, DEFAULT_PRIO ,countArgs(parsed.args1), parsed.args1);</a>
<a name="ln172">		sys_change_process_fd(p1,anonPipe,1);</a>
<a name="ln173"> </a>
<a name="ln174">		pid_t p2 = sys_launch_process(fn2, DEFAULT_PRIO ,countArgs(parsed.args2), parsed.args2);</a>
<a name="ln175">		sys_change_process_fd(p2,anonPipe,0);</a>
<a name="ln176"> </a>
<a name="ln177">		if (!parsed.isBackground) {</a>
<a name="ln178">			fgProccess = p2;</a>
<a name="ln179">			putInFg(p2);</a>
<a name="ln180">		} else {</a>
<a name="ln181">			fgProccess = 0;</a>
<a name="ln182">		}</a>
<a name="ln183"> </a>
<a name="ln184">		return;</a>
<a name="ln185">	}</a>
<a name="ln186"> </a>
<a name="ln187">	void (*fn)(uint8_t, char **) = getFn(parsed.cmd1);</a>
<a name="ln188"> </a>
<a name="ln189">	if ( fn == NULL) {</a>
<a name="ln190">		printf(&quot;Command not found: '%s'\n&quot;, parsed.cmd1);</a>
<a name="ln191">		fgProccess = 0;</a>
<a name="ln192">		return;</a>
<a name="ln193">	}</a>
<a name="ln194"> </a>
<a name="ln195">	pid_t pid = createProcess(fn, DEFAULT_PRIO, countArgs(parsed.args1), parsed.args1);</a>
<a name="ln196">	if (!parsed.isBackground){</a>
<a name="ln197">		fgProccess = pid;</a>
<a name="ln198">		putInFg(pid);</a>
<a name="ln199">	}</a>
<a name="ln200">	if (hasToWait &amp;&amp; fgProccess != 0)</a>
<a name="ln201">	{</a>
<a name="ln202">		wait(fgProccess);</a>
<a name="ln203">	}</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206"> </a>
<a name="ln207">static int countArgs(char **argv) {</a>
<a name="ln208">	int count = 0;</a>
<a name="ln209">	while (argv[count]) {</a>
<a name="ln210">		count++;</a>
<a name="ln211">	}</a>
<a name="ln212">	return count;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">static void parseInput(char *input, ParsedCommand *out) {</a>
<a name="ln216">    out-&gt;hasPipe = 0;</a>
<a name="ln217">    out-&gt;isBackground = 0;</a>
<a name="ln218">    memset(out-&gt;args1, 0, sizeof(out-&gt;args1));</a>
<a name="ln219">    memset(out-&gt;args2, 0, sizeof(out-&gt;args2)); </a>
<a name="ln220"> </a>
<a name="ln221">    int len = strlen(input);</a>
<a name="ln222">    if (len &gt; 0 &amp;&amp; input[len - 1] == '&amp;') {</a>
<a name="ln223">        out-&gt;isBackground = 1;</a>
<a name="ln224">        input[len - 1] = 0;</a>
<a name="ln225">    }</a>
<a name="ln226"> </a>
<a name="ln227">    char *pipePos = strchr(input, '|');</a>
<a name="ln228">    if (pipePos) {</a>
<a name="ln229">        out-&gt;hasPipe = 1;</a>
<a name="ln230">        *pipePos = 0;</a>
<a name="ln231">        pipePos++;</a>
<a name="ln232">    }</a>
<a name="ln233"> </a>
<a name="ln234">    int i = 0;</a>
<a name="ln235">    char *tok = strtok(input, &quot; \t&quot;);</a>
<a name="ln236">    while (tok &amp;&amp; i &lt; MAX_ARGS - 1) {</a>
<a name="ln237">        out-&gt;args1[i++] = tok;</a>
<a name="ln238">        tok = strtok(NULL, &quot; \t&quot;);</a>
<a name="ln239">    }</a>
<a name="ln240">    out-&gt;cmd1 = out-&gt;args1[0];</a>
<a name="ln241"> </a>
<a name="ln242">    if (out-&gt;hasPipe) {</a>
<a name="ln243">        i = 0;</a>
<a name="ln244">        tok = strtok(pipePos, &quot; \t&quot;);</a>
<a name="ln245">        while (tok &amp;&amp; i &lt; MAX_ARGS - 1) {</a>
<a name="ln246">            out-&gt;args2[i++] = tok;</a>
<a name="ln247">            tok = strtok(NULL, &quot; \t&quot;);</a>
<a name="ln248">        }</a>
<a name="ln249">        out-&gt;cmd2 = out-&gt;args2[0];</a>
<a name="ln250">    }</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">static void (*getFn(const char *cmd))(uint8_t, char **) {</a>
<a name="ln254">    for (int i = 0; commandsNames[i] != NULL; i++) {</a>
<a name="ln255">        if (strcmp(commandsNames[i], cmd) == 0) {</a>
<a name="ln256">            return instructionFunctions[i];</a>
<a name="ln257">        }</a>
<a name="ln258">    }</a>
<a name="ln259">    return NULL;</a>
<a name="ln260">}</a>
</code></pre>
<div class="balloon" rel="158"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v614/" target="_blank">V614</a> Uninitialized pointer 'name' used. Consider checking the third actual argument of the 'unsigned_num_to_str' function.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>