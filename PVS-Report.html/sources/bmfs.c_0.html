<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bmfs.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3">/* BareMetal File System Utility */</a>
<a name="ln4">/* Written by Ian Seyler of Return Infinity */</a>
<a name="ln5"> </a>
<a name="ln6">/* Global includes */</a>
<a name="ln7">#include &lt;stdio.h&gt;</a>
<a name="ln8">#include &lt;stdlib.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10">#include &lt;strings.h&gt;</a>
<a name="ln11">#include &lt;ctype.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">/* Global defines */</a>
<a name="ln14">struct BMFSEntry</a>
<a name="ln15">{</a>
<a name="ln16">	char FileName[32];</a>
<a name="ln17">	unsigned long long StartingBlock;</a>
<a name="ln18">	unsigned long long ReservedBlocks;</a>
<a name="ln19">	unsigned long long FileSize;</a>
<a name="ln20">	unsigned long long Unused;</a>
<a name="ln21">};</a>
<a name="ln22"> </a>
<a name="ln23">/* Global constants */</a>
<a name="ln24">// Min disk size is 6MiB (three blocks of 2MiB each.)</a>
<a name="ln25">const unsigned long long minimumDiskSize = (6 * 1024 * 1024);</a>
<a name="ln26"> </a>
<a name="ln27">/* Global variables */</a>
<a name="ln28">FILE *file, *disk;</a>
<a name="ln29">unsigned int filesize, disksize;</a>
<a name="ln30">char tempfilename[32], tempstring[32];</a>
<a name="ln31">char *filename, *diskname, *command;</a>
<a name="ln32">char fs_tag[] = &quot;BMFS&quot;;</a>
<a name="ln33">char s_list[] = &quot;list&quot;;</a>
<a name="ln34">char s_format[] = &quot;format&quot;;</a>
<a name="ln35">char s_initialize[] = &quot;initialize&quot;;</a>
<a name="ln36">char s_create[] = &quot;create&quot;;</a>
<a name="ln37">char s_read[] = &quot;read&quot;;</a>
<a name="ln38">char s_write[] = &quot;write&quot;;</a>
<a name="ln39">char s_delete[] = &quot;delete&quot;;</a>
<a name="ln40">struct BMFSEntry entry;</a>
<a name="ln41">void *pentry = &amp;entry;</a>
<a name="ln42">char *BlockMap;</a>
<a name="ln43">char *FileBlocks;</a>
<a name="ln44">char Directory[4096];</a>
<a name="ln45">char DiskInfo[512];</a>
<a name="ln46"> </a>
<a name="ln47">/* Built-in functions */</a>
<a name="ln48">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber);</a>
<a name="ln49">void list();</a>
<a name="ln50">void format();</a>
<a name="ln51">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel);</a>
<a name="ln52">void create(char *filename, unsigned long long maxsize);</a>
<a name="ln53">void read(char *filename);</a>
<a name="ln54">void write(char *filename);</a>
<a name="ln55">void delete(char *filename);</a>
<a name="ln56"> </a>
<a name="ln57">/* Program code */</a>
<a name="ln58">int main(int argc, char *argv[])</a>
<a name="ln59">{</a>
<a name="ln60">	/* Parse arguments */</a>
<a name="ln61">	if (argc &lt; 3)</a>
<a name="ln62">	{</a>
<a name="ln63">		printf(&quot;BareMetal File System Utility v1.0 (2013 04 10)\n&quot;);</a>
<a name="ln64">		printf(&quot;Written by Ian Seyler @ Return Infinity (ian.seyler@returninfinity.com)\n\n&quot;);</a>
<a name="ln65">		printf(&quot;Usage: %s disk function file\n&quot;, argv[0]);</a>
<a name="ln66">		printf(&quot;Disk: the name of the disk file\n&quot;);</a>
<a name="ln67">		printf(&quot;Function: list, read, write, create, delete, format, initialize\n&quot;);</a>
<a name="ln68">		printf(&quot;File: (if applicable)\n&quot;);</a>
<a name="ln69">		exit(0);</a>
<a name="ln70">	}</a>
<a name="ln71"> </a>
<a name="ln72">	diskname = argv[1];</a>
<a name="ln73">	command = argv[2];</a>
<a name="ln74">	filename = argv[3];</a>
<a name="ln75"> </a>
<a name="ln76">	if (strcasecmp(s_initialize, command) == 0)</a>
<a name="ln77">	{</a>
<a name="ln78">		if (argc &gt;= 4)</a>
<a name="ln79">		{</a>
<a name="ln80">			char *size = argv[3];  // Required</a>
<a name="ln81">			char *mbr = (argc &gt; 4 ? argv[4] : NULL);    // Opt.</a>
<a name="ln82">			char *boot = (argc &gt; 5 ? argv[5] : NULL);   // Opt.</a>
<a name="ln83">			char *kernel = (argc &gt; 6 ? argv[6] : NULL); // Opt.</a>
<a name="ln84">			int ret = initialize(diskname, size, mbr, boot, kernel);</a>
<a name="ln85">			exit(ret);</a>
<a name="ln86">		}</a>
<a name="ln87">		else</a>
<a name="ln88">		{</a>
<a name="ln89">			printf(&quot;Usage: %s disk %s &quot;, argv[0], command);</a>
<a name="ln90">			printf(&quot;size [mbr_file] &quot;);</a>
<a name="ln91">			printf(&quot;[bootloader_file] [kernel_file]\n&quot;);</a>
<a name="ln92">			exit(1);</a>
<a name="ln93">		}</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">	if ((disk = fopen(diskname, &quot;r+b&quot;)) == NULL)	// Open for read/write in binary mode</a>
<a name="ln97">	{</a>
<a name="ln98">		printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln99">		exit(0);</a>
<a name="ln100">	}</a>
<a name="ln101">	else	// Opened ok, is it a valid BMFS disk?</a>
<a name="ln102">	{</a>
<a name="ln103">		fseek(disk, 0, SEEK_END);</a>
<a name="ln104">		disksize = ftell(disk) / 1048576;			// Disk size in MiB</a>
<a name="ln105">		fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln106">		fread(DiskInfo, 512, 1, disk);				// Read 512 bytes to the DiskInfo buffer</a>
<a name="ln107">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln108">		fread(Directory, 4096, 1, disk);			// Read 4096 bytes to the Directory buffer</a>
<a name="ln109">		rewind(disk);</a>
<a name="ln110">		</a>
<a name="ln111">		if (strcasecmp(DiskInfo, fs_tag) != 0)		// Is it a BMFS formatted disk?</a>
<a name="ln112">		{</a>
<a name="ln113">			if (strcasecmp(s_format, command) == 0)</a>
<a name="ln114">			{</a>
<a name="ln115">				format();</a>
<a name="ln116">			}</a>
<a name="ln117">			else</a>
<a name="ln118">			{</a>
<a name="ln119">				printf(&quot;Error: Not a valid BMFS drive (Disk is not BMFS formatted).\n&quot;);</a>
<a name="ln120">			}</a>
<a name="ln121">			fclose(disk);</a>
<a name="ln122">			return 0;</a>
<a name="ln123">		}</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">	if (strcasecmp(s_list, command) == 0)</a>
<a name="ln127">	{</a>
<a name="ln128">		list();</a>
<a name="ln129">	}</a>
<a name="ln130">	else if (strcasecmp(s_format, command) == 0)</a>
<a name="ln131">	{</a>
<a name="ln132">		if (argc &gt; 3)</a>
<a name="ln133">		{</a>
<a name="ln134">			if (strcasecmp(argv[3], &quot;/FORCE&quot;) == 0)</a>
<a name="ln135">			{</a>
<a name="ln136">				format();</a>
<a name="ln137">			}</a>
<a name="ln138">			else</a>
<a name="ln139">			{</a>
<a name="ln140">				printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln141">			}</a>
<a name="ln142">		}</a>
<a name="ln143">		else	</a>
<a name="ln144">		{</a>
<a name="ln145">			printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln146">		}</a>
<a name="ln147">	}</a>
<a name="ln148">	else if (strcasecmp(s_create, command) == 0)</a>
<a name="ln149">	{</a>
<a name="ln150">		if (filename == NULL)</a>
<a name="ln151">		{</a>
<a name="ln152">			printf(&quot;Error: File name not specified.\n&quot;);</a>
<a name="ln153">		}</a>
<a name="ln154">		else</a>
<a name="ln155">		{</a>
<a name="ln156">			if (argc &gt; 4)</a>
<a name="ln157">			{</a>
<a name="ln158">				int filesize = atoi(argv[4]);</a>
<a name="ln159">				if (filesize &gt;= 1)</a>
<a name="ln160">				{</a>
<a name="ln161">					create(filename, filesize);</a>
<a name="ln162">				}</a>
<a name="ln163">				else</a>
<a name="ln164">				{</a>
<a name="ln165">			  		printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln166">				}</a>
<a name="ln167">			}</a>
<a name="ln168">			else</a>
<a name="ln169">			{</a>
<a name="ln170">				printf(&quot;Maximum file size in MiB: &quot;);</a>
<a name="ln171">				fgets(tempstring, 32, stdin);			// Get up to 32 chars from the keyboard</a>
<a name="ln172">				filesize = atoi(tempstring);</a>
<a name="ln173">				if (filesize &gt;= 1)</a>
<a name="ln174">					create(filename, filesize);</a>
<a name="ln175">				else</a>
<a name="ln176">					printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln177">			}</a>
<a name="ln178">		}</a>
<a name="ln179">	}</a>
<a name="ln180">	else if (strcasecmp(s_read, command) == 0)</a>
<a name="ln181">	{</a>
<a name="ln182">		read(filename);</a>
<a name="ln183">	}</a>
<a name="ln184">	else if (strcasecmp(s_write, command) == 0)</a>
<a name="ln185">	{</a>
<a name="ln186">		write(filename);</a>
<a name="ln187">	}</a>
<a name="ln188">	else if (strcasecmp(s_delete, command) == 0)</a>
<a name="ln189">	{</a>
<a name="ln190">		delete(filename);</a>
<a name="ln191">	}</a>
<a name="ln192">	else</a>
<a name="ln193">	{</a>
<a name="ln194">		printf(&quot;Unknown command\n&quot;);</a>
<a name="ln195">	}</a>
<a name="ln196">	if (disk != NULL)</a>
<a name="ln197">	{</a>
<a name="ln198">		fclose( disk );</a>
<a name="ln199">		disk = NULL;</a>
<a name="ln200">	}</a>
<a name="ln201">	return 0;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber)</a>
<a name="ln206">{</a>
<a name="ln207">	int tint;</a>
<a name="ln208"> </a>
<a name="ln209">	for (tint = 0; tint &lt; 64; tint++)</a>
<a name="ln210">	{</a>
<a name="ln211">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln212">		if (entry.FileName[0] == 0x00)				// End of directory</a>
<a name="ln213">		{</a>
<a name="ln214">			tint = 64;</a>
<a name="ln215">		}</a>
<a name="ln216">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln217">		{</a>
<a name="ln218">			// Ignore</a>
<a name="ln219">		}</a>
<a name="ln220">		else										// Valid entry</a>
<a name="ln221">		{</a>
<a name="ln222">			if (strcmp(filename, entry.FileName) == 0)</a>
<a name="ln223">			{</a>
<a name="ln224">				memcpy(fileentry, pentry, 64);</a>
<a name="ln225">				*entrynumber = tint;</a>
<a name="ln226">				return 1;</a>
<a name="ln227">			}</a>
<a name="ln228">		}	</a>
<a name="ln229">	}</a>
<a name="ln230">	return 0;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">void list()</a>
<a name="ln235">{</a>
<a name="ln236">	int tint;</a>
<a name="ln237"> </a>
<a name="ln238">	printf(&quot;%s\nDisk Size: %d MiB\n&quot;, diskname, disksize);</a>
<a name="ln239">	printf(&quot;Name                            |            Size (B)|      Reserved (MiB)\n&quot;);</a>
<a name="ln240">	printf(&quot;==========================================================================\n&quot;);</a>
<a name="ln241">	for (tint = 0; tint &lt; 64; tint++)			// Max 64 entries</a>
<a name="ln242">	{</a>
<a name="ln243">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln244">		if (entry.FileName[0] == 0x00)				// End of directory, bail out</a>
<a name="ln245">		{</a>
<a name="ln246">			tint = 64;</a>
<a name="ln247">		}</a>
<a name="ln248">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln249">		{</a>
<a name="ln250">			// Ignore</a>
<a name="ln251">		}</a>
<a name="ln252">		else										// Valid entry</a>
<a name="ln253">		{</a>
<a name="ln254">			printf(&quot;%-32s %20lld %20lld\n&quot;, entry.FileName, entry.FileSize, (entry.ReservedBlocks*2));</a>
<a name="ln255">		}</a>
<a name="ln256">	}</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">void format()</a>
<a name="ln261">{</a>
<a name="ln262">	memset(DiskInfo, 0, 512);</a>
<a name="ln263">	memset(Directory, 0, 4096);</a>
<a name="ln264">	memcpy(DiskInfo, fs_tag, 4);				// Add the 'BMFS' tag</a>
<a name="ln265">	fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln266">	fwrite(DiskInfo, 512, 1, disk);			// Write 512 bytes for the DiskInfo</a>
<a name="ln267">	fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln268">	fwrite(Directory, 4096, 1, disk);		// Write 4096 bytes for the Directory</a>
<a name="ln269">	printf(&quot;Format complete.\n&quot;);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel)</a>
<a name="ln274">{</a>
<a name="ln275">	unsigned long long diskSize = 0;</a>
<a name="ln276">	unsigned long long writeSize = 0;</a>
<a name="ln277">	const char *bootFileType = NULL;</a>
<a name="ln278">	size_t bufferSize = 50 * 1024;</a>
<a name="ln279">	char * buffer = NULL;</a>
<a name="ln280">	FILE *mbrFile = NULL;</a>
<a name="ln281">	FILE *bootFile = NULL;</a>
<a name="ln282">	FILE *kernelFile = NULL;</a>
<a name="ln283">	int diskSizeFactor = 0;</a>
<a name="ln284">	size_t chunkSize = 0;</a>
<a name="ln285">	int ret = 0;</a>
<a name="ln286">	size_t i;</a>
<a name="ln287"> </a>
<a name="ln288">	// Determine how the second file will be described in output messages.</a>
<a name="ln289">	// If a kernel file is specified too, then assume the second file is the</a>
<a name="ln290">	// boot loader.  If no kernel file is specified, assume the boot loader</a>
<a name="ln291">	// and kernel are combined into one system file.</a>
<a name="ln292">	if (boot != NULL)</a>
<a name="ln293">	{</a>
<a name="ln294">		bootFileType = &quot;boot loader&quot;;</a>
<a name="ln295">		if (kernel == NULL)</a>
<a name="ln296">		{</a>
<a name="ln297">			bootFileType = &quot;system&quot;;</a>
<a name="ln298">		}</a>
<a name="ln299">	}</a>
<a name="ln300"> </a>
<a name="ln301">	// Validate the disk size string and convert it to an integer value.</a>
<a name="ln302">	for (i = 0; size[i] != '\0' &amp;&amp; ret == 0; ++i)</a>
<a name="ln303">	{</a>
<a name="ln304">		char ch = size[i];</a>
<a name="ln305">		if (isdigit(ch))</a>
<a name="ln306">		{</a>
<a name="ln307">			unsigned int n = ch - '0';</a>
<a name="ln308">			if (diskSize * 10 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln309">			{</a>
<a name="ln310">				diskSize *= 10;</a>
<a name="ln311">				diskSize += n;</a>
<a name="ln312">			}</a>
<a name="ln313">			else if (diskSize == 0) // First loop iteration</a>
<a name="ln314">			{</a>
<a name="ln315">				diskSize += n;</a>
<a name="ln316">			}</a>
<a name="ln317">			else</a>
<a name="ln318">			{</a>
<a name="ln319">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln320">				ret = 1;</a>
<a name="ln321">			}</a>
<a name="ln322">		}</a>
<a name="ln323">		else if (i == 0) // No digits specified</a>
<a name="ln324">		{</a>
<a name="ln325">			printf(&quot;Error: A numeric disk size must be specified\n&quot;);</a>
<a name="ln326">			ret = 1;</a>
<a name="ln327">		}</a>
<a name="ln328">		else</a>
<a name="ln329">		{</a>
<a name="ln330">			switch (toupper(ch))</a>
<a name="ln331">			{</a>
<a name="ln332">					case 'K':</a>
<a name="ln333">						diskSizeFactor = 1;</a>
<a name="ln334">						break;</a>
<a name="ln335">					case 'M':</a>
<a name="ln336">						diskSizeFactor = 2;</a>
<a name="ln337">						break;</a>
<a name="ln338">					case 'G':</a>
<a name="ln339">						diskSizeFactor = 3;</a>
<a name="ln340">						break;</a>
<a name="ln341">					case 'T':</a>
<a name="ln342">						diskSizeFactor = 4;</a>
<a name="ln343">						break;</a>
<a name="ln344">					case 'P':</a>
<a name="ln345">						diskSizeFactor = 5;</a>
<a name="ln346">						break;</a>
<a name="ln347">					default:</a>
<a name="ln348">						printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln349">						ret = 1;</a>
<a name="ln350">						break;</a>
<a name="ln351">			}</a>
<a name="ln352"> </a>
<a name="ln353">			// If this character is a valid unit indicator, but is not at the</a>
<a name="ln354">			// end of the string, then the string is invalid.</a>
<a name="ln355">			if (ret == 0 &amp;&amp; size[i+1] != '\0')</a>
<a name="ln356">			{</a>
<a name="ln357">				printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln358">				ret = 1;</a>
<a name="ln359">			}</a>
<a name="ln360">		}</a>
<a name="ln361">	}</a>
<a name="ln362"> </a>
<a name="ln363">	// Adjust the disk size if a unit indicator was given.  Note that an</a>
<a name="ln364">	// input of something like &quot;0&quot; or &quot;0K&quot; will get past the checks above.</a>
<a name="ln365">	if (ret == 0 &amp;&amp; diskSize &gt; 0 &amp;&amp; diskSizeFactor &gt; 0)</a>
<a name="ln366">	{</a>
<a name="ln367">		while (diskSizeFactor--)</a>
<a name="ln368">		{</a>
<a name="ln369">			if (diskSize * 1024 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln370">			{</a>
<a name="ln371">				diskSize *= 1024;</a>
<a name="ln372">			}</a>
<a name="ln373">			else</a>
<a name="ln374">			{</a>
<a name="ln375">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln376">				ret = 1;</a>
<a name="ln377">			}</a>
<a name="ln378">		}</a>
<a name="ln379">	}</a>
<a name="ln380"> </a>
<a name="ln381">	// Make sure the disk size is large enough.</a>
<a name="ln382">	if (ret == 0)</a>
<a name="ln383">	{</a>
<a name="ln384">		if (diskSize &lt; minimumDiskSize)</a>
<a name="ln385">		{</a>
<a name="ln386">			printf( &quot;Error: Disk size must be at least %llu bytes (%lluMiB)\n&quot;, minimumDiskSize, minimumDiskSize / (1024*1024));</a>
<a name="ln387">			ret = 1;</a>
<a name="ln388">		}</a>
<a name="ln389">	}</a>
<a name="ln390"> </a>
<a name="ln391">	// Open the Master boot Record file for reading.</a>
<a name="ln392">	if (ret == 0 &amp;&amp; mbr != NULL)</a>
<a name="ln393">	{</a>
<a name="ln394">		mbrFile = fopen(mbr, &quot;rb&quot;);</a>
<a name="ln395">		if (mbrFile == NULL )</a>
<a name="ln396">		{</a>
<a name="ln397">			printf(&quot;Error: Unable to open MBR file '%s'\n&quot;, mbr);</a>
<a name="ln398">			ret = 1;</a>
<a name="ln399">		}</a>
<a name="ln400">	}</a>
<a name="ln401"> </a>
<a name="ln402">	// Open the boot loader file for reading.</a>
<a name="ln403">	if (ret == 0 &amp;&amp; boot != NULL)</a>
<a name="ln404">	{</a>
<a name="ln405">		bootFile = fopen(boot, &quot;rb&quot;);</a>
<a name="ln406">		if (bootFile == NULL )</a>
<a name="ln407">		{</a>
<a name="ln408">			printf(&quot;Error: Unable to open %s file '%s'\n&quot;, bootFileType, boot);</a>
<a name="ln409">			ret = 1;</a>
<a name="ln410">		}</a>
<a name="ln411">	}</a>
<a name="ln412"> </a>
<a name="ln413">	// Open the kernel file for reading.</a>
<a name="ln414">	if (ret == 0 &amp;&amp; kernel != NULL)</a>
<a name="ln415">	{</a>
<a name="ln416">		kernelFile = fopen(kernel, &quot;rb&quot;);</a>
<a name="ln417">		if (kernelFile == NULL )</a>
<a name="ln418">		{</a>
<a name="ln419">			printf(&quot;Error: Unable to open kernel file '%s'\n&quot;, kernel);</a>
<a name="ln420">			ret = 1;</a>
<a name="ln421">		}</a>
<a name="ln422">	}</a>
<a name="ln423"> </a>
<a name="ln424">	// Allocate buffer to use for filling the disk image with zeros.</a>
<a name="ln425">	if (ret == 0)</a>
<a name="ln426">	{</a>
<a name="ln427">		buffer = (char *) malloc(bufferSize);</a>
<a name="ln428">		if (buffer == NULL)</a>
<a name="ln429">		{</a>
<a name="ln430">			printf(&quot;Error: Failed to allocate buffer\n&quot;);</a>
<a name="ln431">			ret = 1;</a>
<a name="ln432">		}</a>
<a name="ln433">	}</a>
<a name="ln434"> </a>
<a name="ln435">	// Open the disk image file for writing.  This will truncate the disk file</a>
<a name="ln436">	// if it already exists, so we should do this only after we're ready to</a>
<a name="ln437">	// actually write to the file.</a>
<a name="ln438">	if (ret == 0)</a>
<a name="ln439">	{</a>
<a name="ln440">		disk = fopen(diskname, &quot;wb&quot;);</a>
<a name="ln441">		if (disk == NULL)</a>
<a name="ln442">		{</a>
<a name="ln443">			printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln444">			ret = 1;</a>
<a name="ln445">		}</a>
<a name="ln446">	}</a>
<a name="ln447"> </a>
<a name="ln448">	// Fill the disk image with zeros.</a>
<a name="ln449">	if (ret == 0)</a>
<a name="ln450">	{</a>
<a name="ln451">		double percent;</a>
<a name="ln452">		memset(buffer, 0, bufferSize);</a>
<a name="ln453">		writeSize = 0;</a>
<a name="ln454">		while (writeSize &lt; diskSize)</a>
<a name="ln455">		{</a>
<a name="ln456">			percent = writeSize;</a>
<a name="ln457">			percent /= diskSize;</a>
<a name="ln458">			percent *= 100;</a>
<a name="ln459">			printf(&quot;Formatting disk: %llu of %llu bytes (%.0f%%)...\r&quot;, writeSize, diskSize, percent);</a>
<a name="ln460">			chunkSize = bufferSize;</a>
<a name="ln461">			if (chunkSize &gt; diskSize - writeSize)</a>
<a name="ln462">			{</a>
<a name="ln463">				chunkSize = diskSize - writeSize;</a>
<a name="ln464">			}</a>
<a name="ln465">			if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln466">			{</a>
<a name="ln467">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln468">				ret = 1;</a>
<a name="ln469">				break;</a>
<a name="ln470">			}</a>
<a name="ln471">			writeSize += chunkSize;</a>
<a name="ln472">		}</a>
<a name="ln473">		if (ret == 0)</a>
<a name="ln474">		{</a>
<a name="ln475">			printf(&quot;Formatting disk: %llu of %llu bytes (100%%)%9s\n&quot;, writeSize, diskSize, &quot;&quot;);</a>
<a name="ln476">		}</a>
<a name="ln477">	}</a>
<a name="ln478"> </a>
<a name="ln479">	// Format the disk.</a>
<a name="ln480">	if (ret == 0)</a>
<a name="ln481">	{</a>
<a name="ln482">		rewind(disk);</a>
<a name="ln483">		format();</a>
<a name="ln484">	}</a>
<a name="ln485"> </a>
<a name="ln486">	// Write the master boot record if it was specified by the caller.</a>
<a name="ln487">	if (ret == 0 &amp;&amp; mbrFile !=NULL)</a>
<a name="ln488">	{</a>
<a name="ln489">		printf(&quot;Writing master boot record.\n&quot;);</a>
<a name="ln490">		fseek(disk, 0, SEEK_SET);</a>
<a name="ln491">		if (fread(buffer, 512, 1, mbrFile) == 1)</a>
<a name="ln492">		{</a>
<a name="ln493">			if (fwrite(buffer, 512, 1, disk) != 1)</a>
<a name="ln494">			{</a>
<a name="ln495">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln496">				ret = 1;</a>
<a name="ln497">			}</a>
<a name="ln498">		}</a>
<a name="ln499">		else</a>
<a name="ln500">		{</a>
<a name="ln501">			printf(&quot;Error: Failed to read file '%s'\n&quot;, mbr);</a>
<a name="ln502">			ret = 1;</a>
<a name="ln503">		}</a>
<a name="ln504">	}</a>
<a name="ln505"> </a>
<a name="ln506">	// Write the boot loader if it was specified by the caller.</a>
<a name="ln507">	if (ret == 0 &amp;&amp; bootFile !=NULL)</a>
<a name="ln508">	{</a>
<a name="ln509">		printf(&quot;Writing %s file.\n&quot;, bootFileType);</a>
<a name="ln510">		fseek(disk, 8192, SEEK_SET);</a>
<a name="ln511">		for (;;)</a>
<a name="ln512">		{</a>
<a name="ln513">			chunkSize = fread( buffer, 1, bufferSize, bootFile);</a>
<a name="ln514">			if (chunkSize &gt; 0)</a>
<a name="ln515">			{</a>
<a name="ln516">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln517">				{</a>
<a name="ln518">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln519">					ret = 1;</a>
<a name="ln520">				}</a>
<a name="ln521">			}</a>
<a name="ln522">			else</a>
<a name="ln523">			{</a>
<a name="ln524">				if (ferror(disk))</a>
<a name="ln525">				{</a>
<a name="ln526">					printf(&quot;Error: Failed to read file '%s'\n&quot;, boot);</a>
<a name="ln527">					ret = 1;</a>
<a name="ln528">				}</a>
<a name="ln529">				break;</a>
<a name="ln530">			}</a>
<a name="ln531">		}</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	// Write the kernel if it was specified by the caller. The kernel must</a>
<a name="ln535">	// immediately follow the boot loader on disk (i.e. no seek needed.)</a>
<a name="ln536">	if (ret == 0 &amp;&amp; kernelFile !=NULL)</a>
<a name="ln537">	{</a>
<a name="ln538">		printf(&quot;Writing kernel.\n&quot;);</a>
<a name="ln539">		for (;;)</a>
<a name="ln540">		{</a>
<a name="ln541">			chunkSize = fread( buffer, 1, bufferSize, kernelFile);</a>
<a name="ln542">			if (chunkSize &gt; 0)</a>
<a name="ln543">			{</a>
<a name="ln544">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln545">				{</a>
<a name="ln546">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln547">					ret = 1;</a>
<a name="ln548">				}</a>
<a name="ln549">			}</a>
<a name="ln550">			else</a>
<a name="ln551">			{</a>
<a name="ln552">				if (ferror(disk))</a>
<a name="ln553">				{</a>
<a name="ln554">					printf(&quot;Error: Failed to read file '%s'\n&quot;, kernel);</a>
<a name="ln555">					ret = 1;</a>
<a name="ln556">				}</a>
<a name="ln557">				break;</a>
<a name="ln558">			}</a>
<a name="ln559">		}</a>
<a name="ln560">	}</a>
<a name="ln561"> </a>
<a name="ln562">	// Close any files that were opened.</a>
<a name="ln563">	if (mbrFile != NULL)</a>
<a name="ln564">	{</a>
<a name="ln565">		fclose(mbrFile);</a>
<a name="ln566">	}</a>
<a name="ln567">	if (bootFile != NULL)</a>
<a name="ln568">	{</a>
<a name="ln569">		fclose(bootFile);</a>
<a name="ln570">	}</a>
<a name="ln571">	if (kernelFile != NULL)</a>
<a name="ln572">	{</a>
<a name="ln573">		fclose(kernelFile);</a>
<a name="ln574">	}</a>
<a name="ln575">	if (disk != NULL)</a>
<a name="ln576">	{</a>
<a name="ln577">		fclose(disk);</a>
<a name="ln578">		disk = NULL;</a>
<a name="ln579">	}</a>
<a name="ln580"> </a>
<a name="ln581">	// Free the buffer if it was allocated.</a>
<a name="ln582">	if (buffer != NULL)</a>
<a name="ln583">	{</a>
<a name="ln584">		free(buffer);</a>
<a name="ln585">	}</a>
<a name="ln586"> </a>
<a name="ln587">	if (ret == 0)</a>
<a name="ln588">	{</a>
<a name="ln589">		printf(&quot;Disk initialization complete.\n&quot;);</a>
<a name="ln590">	}</a>
<a name="ln591"> </a>
<a name="ln592">	return ret;</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595"> </a>
<a name="ln596">// helper function for qsort, sorts by StartingBlock field</a>
<a name="ln597">static int StartingBlockCmp(const void *pa, const void *pb)</a>
<a name="ln598">{</a>
<a name="ln599">	struct BMFSEntry *ea = (struct BMFSEntry *)pa;</a>
<a name="ln600">	struct BMFSEntry *eb = (struct BMFSEntry *)pb;</a>
<a name="ln601">	// empty records go to the end</a>
<a name="ln602">	if (ea-&gt;FileName[0] == 0x01)</a>
<a name="ln603">		return 1;</a>
<a name="ln604">	if (eb-&gt;FileName[0] == 0x01)</a>
<a name="ln605">		return -1;</a>
<a name="ln606">	// compare non-empty records by their starting blocks number</a>
<a name="ln607">	return (ea-&gt;StartingBlock - eb-&gt;StartingBlock);</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">void create(char *filename, unsigned long long maxsize)</a>
<a name="ln611">{</a>
<a name="ln612">	struct BMFSEntry tempentry;</a>
<a name="ln613">	int slot;</a>
<a name="ln614">	</a>
<a name="ln615">	if (maxsize % 2 != 0)</a>
<a name="ln616">		maxsize++;</a>
<a name="ln617"> </a>
<a name="ln618">	if (findfile(filename, &amp;tempentry, &amp;slot) == 0)</a>
<a name="ln619">	{</a>
<a name="ln620">		unsigned long long blocks_requested = maxsize / 2; // how many blocks to allocate</a>
<a name="ln621">		unsigned long long num_blocks = disksize / 2; // number of blocks in the disk</a>
<a name="ln622">		char dir_copy[4096]; // copy of directory</a>
<a name="ln623">		int num_used_entries = 0; // how many entries of Directory are either used or deleted</a>
<a name="ln624">		int first_free_entry = -1; // where to put new entry</a>
<a name="ln625">		int tint;</a>
<a name="ln626">		struct BMFSEntry *pEntry;</a>
<a name="ln627">		unsigned long long new_file_start = 0;</a>
<a name="ln628">		unsigned long long prev_file_end = 1;</a>
<a name="ln629"> </a>
<a name="ln630">		printf(&quot;Creating new file...\n&quot;);</a>
<a name="ln631"> </a>
<a name="ln632">		// Make a copy of Directory to play with</a>
<a name="ln633">		memcpy(dir_copy, Directory, 4096);</a>
<a name="ln634"> </a>
<a name="ln635">		// Calculate number of files</a>
<a name="ln636">		for (tint = 0; tint &lt; 64; tint++) </a>
<a name="ln637">		{</a>
<a name="ln638">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln639">			if (pEntry-&gt;FileName[0] == 0x00) // end of directory</a>
<a name="ln640">			{</a>
<a name="ln641">				num_used_entries = tint;</a>
<a name="ln642">				if (first_free_entry == -1)</a>
<a name="ln643">					first_free_entry = tint; // there were no unused entires before, will use this one</a>
<a name="ln644">				break;</a>
<a name="ln645">			}</a>
<a name="ln646">			else if (pEntry-&gt;FileName[0] == 0x01) // unused entry</a>
<a name="ln647">			{</a>
<a name="ln648">				if (first_free_entry == -1)</a>
<a name="ln649">					first_free_entry = tint; // will use it for our new file</a>
<a name="ln650">			}</a>
<a name="ln651">		}</a>
<a name="ln652"> </a>
<a name="ln653">		if (first_free_entry == -1)</a>
<a name="ln654">		{</a>
<a name="ln655">			printf(&quot;Cannot create file: no free directory entries.\n&quot;);</a>
<a name="ln656">			return;</a>
<a name="ln657">		}</a>
<a name="ln658"> </a>
<a name="ln659">		// Find an area with enough free blocks</a>
<a name="ln660">		// Sort our copy of the directory by starting block number</a>
<a name="ln661">		qsort(dir_copy, num_used_entries, 64, StartingBlockCmp);</a>
<a name="ln662"> </a>
<a name="ln663">		for (tint = 0; tint &lt; num_used_entries + 1; tint++)</a>
<a name="ln664">		{</a>
<a name="ln665">			// on each iteration of this loop we'll see if a new file can fit</a>
<a name="ln666">			// between the end of the previous file (initially == 1) </a>
<a name="ln667">			// and the beginning of the current file (or the last data block if there are no more files).</a>
<a name="ln668"> </a>
<a name="ln669">			unsigned long long this_file_start;</a>
<a name="ln670">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln671"> </a>
<a name="ln672">			if (tint == num_used_entries || pEntry-&gt;FileName[0] == 0x01) </a>
<a name="ln673">				this_file_start = num_blocks - 1; // index of the last block</a>
<a name="ln674">			else</a>
<a name="ln675">				this_file_start = pEntry-&gt;StartingBlock;</a>
<a name="ln676"> </a>
<a name="ln677">			if (this_file_start - prev_file_end &gt;= blocks_requested) </a>
<a name="ln678">			{ // fits here</a>
<a name="ln679">				new_file_start = prev_file_end;</a>
<a name="ln680">				break;</a>
<a name="ln681">			}</a>
<a name="ln682"> </a>
<a name="ln683">			if (tint &lt; num_used_entries)</a>
<a name="ln684">				prev_file_end = pEntry-&gt;StartingBlock + pEntry-&gt;ReservedBlocks;</a>
<a name="ln685">		}</a>
<a name="ln686"> </a>
<a name="ln687">		if (new_file_start == 0) </a>
<a name="ln688">		{</a>
<a name="ln689">			printf(&quot;Cannot create file of size %lld MiB.\n&quot;, maxsize);</a>
<a name="ln690">			return;</a>
<a name="ln691">		}</a>
<a name="ln692"> </a>
<a name="ln693">		// Add file record to Directory</a>
<a name="ln694">		pEntry = (struct BMFSEntry *)(Directory + first_free_entry * 64);</a>
<a name="ln695">		pEntry-&gt;StartingBlock = new_file_start;</a>
<a name="ln696">		pEntry-&gt;ReservedBlocks = blocks_requested;</a>
<a name="ln697">		pEntry-&gt;FileSize = 0;</a>
<a name="ln698">		strcpy(pEntry-&gt;FileName, filename);</a>
<a name="ln699"> </a>
<a name="ln700">		if (first_free_entry == num_used_entries &amp;&amp; num_used_entries + 1 &lt; 64)</a>
<a name="ln701">		{</a>
<a name="ln702">			// here we used the record that was marked with 0x00, </a>
<a name="ln703">			// so make sure to mark the next record with 0x00 if it exists</a>
<a name="ln704">			pEntry = (struct BMFSEntry *)(Directory + (num_used_entries + 1) * 64);</a>
<a name="ln705">			pEntry-&gt;FileName[0] = 0x00;</a>
<a name="ln706">		}</a>
<a name="ln707"> </a>
<a name="ln708">		// Flush Directory to disk</a>
<a name="ln709">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln710">		fwrite(Directory, 4096, 1, disk);			// Write 4096 bytes for the Directory</a>
<a name="ln711"> </a>
<a name="ln712">//		printf(&quot;Complete: file %s starts at block %lld, directory entry #%d.\n&quot;, filename, new_file_start, first_free_entry);</a>
<a name="ln713">		printf(&quot;Complete\n&quot;);</a>
<a name="ln714">	}</a>
<a name="ln715">	else</a>
<a name="ln716">	{</a>
<a name="ln717">		printf(&quot;Error: File already exists.\n&quot;);</a>
<a name="ln718">	}</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">void read(char *filename)</a>
<a name="ln723">{</a>
<a name="ln724">	struct BMFSEntry tempentry;</a>
<a name="ln725">	FILE *tfile;</a>
<a name="ln726">	int tint, slot;</a>
<a name="ln727"> </a>
<a name="ln728">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln729">	{</a>
<a name="ln730">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln731">	}</a>
<a name="ln732">	else</a>
<a name="ln733">	{</a>
<a name="ln734">		printf(&quot;Reading '%s' from BMFS to local file... &quot;, filename);</a>
<a name="ln735">		if ((tfile = fopen(tempentry.FileName, &quot;wb&quot;)) == NULL)</a>
<a name="ln736">		{</a>
<a name="ln737">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln738">		}</a>
<a name="ln739">		else</a>
<a name="ln740">		{</a>
<a name="ln741">			fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln742">			for (tint=0; tint&lt;tempentry.FileSize; tint++)</a>
<a name="ln743">			{</a>
<a name="ln744">				putc(getc(disk), tfile);			// This is really terrible.</a>
<a name="ln745">				// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln746">			}</a>
<a name="ln747">			fclose(tfile);</a>
<a name="ln748">			printf(&quot;Complete\n&quot;);</a>
<a name="ln749">		}</a>
<a name="ln750">	}</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">void write(char *filename)</a>
<a name="ln755">{</a>
<a name="ln756">	struct BMFSEntry tempentry;</a>
<a name="ln757">	FILE *tfile;</a>
<a name="ln758">	int tint, slot;</a>
<a name="ln759">	unsigned long long tempfilesize;</a>
<a name="ln760"> </a>
<a name="ln761">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln762">	{</a>
<a name="ln763">		printf(&quot;Error: File not found in BMFS. A file entry must first be created.\n&quot;);</a>
<a name="ln764">	}</a>
<a name="ln765">	else</a>
<a name="ln766">	{</a>
<a name="ln767">		printf(&quot;Writing local file '%s' to BMFS... &quot;, filename);</a>
<a name="ln768">		if ((tfile = fopen(filename, &quot;rb&quot;)) == NULL)</a>
<a name="ln769">		{</a>
<a name="ln770">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln771">		}</a>
<a name="ln772">		else</a>
<a name="ln773">		{</a>
<a name="ln774">			// Is there enough room in BMFS?</a>
<a name="ln775">			fseek(tfile, 0, SEEK_END);</a>
<a name="ln776">			tempfilesize = ftell(tfile);</a>
<a name="ln777">			rewind(tfile);</a>
<a name="ln778">			if ((tempentry.ReservedBlocks*2097152) &lt; tempfilesize)</a>
<a name="ln779">			{</a>
<a name="ln780">				printf(&quot;Not enough reserved space in BMFS.\n&quot;);</a>
<a name="ln781">			}</a>
<a name="ln782">			else</a>
<a name="ln783">			{</a>
<a name="ln784">				fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln785">				for (tint=0; tint&lt;tempfilesize; tint++)</a>
<a name="ln786">				{</a>
<a name="ln787">					putc(getc(tfile), disk);			// This is really terrible.</a>
<a name="ln788">					// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln789">				}</a>
<a name="ln790">				// Update directory</a>
<a name="ln791">				memcpy(Directory+(slot*64)+48, &amp;tempfilesize, 8);</a>
<a name="ln792">				fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln793">				fwrite(Directory, 4096, 1, disk);			// Write new directory to disk</a>
<a name="ln794">				printf(&quot;Complete\n&quot;);</a>
<a name="ln795">			}</a>
<a name="ln796">			fclose(tfile);</a>
<a name="ln797">		}</a>
<a name="ln798">	}</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801"> </a>
<a name="ln802">void delete(char *filename)</a>
<a name="ln803">{</a>
<a name="ln804">	struct BMFSEntry tempentry;</a>
<a name="ln805">	char delmarker = 0x01;</a>
<a name="ln806">	int slot;</a>
<a name="ln807"> </a>
<a name="ln808">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln809">	{</a>
<a name="ln810">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln811">	}</a>
<a name="ln812">	else</a>
<a name="ln813">	{</a>
<a name="ln814">		printf(&quot;Deleting file '%s' from BMFS... &quot;, filename);</a>
<a name="ln815">		// Update directory</a>
<a name="ln816">		memcpy(Directory+(slot*64), &amp;delmarker, 1);</a>
<a name="ln817">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln818">		fwrite(Directory, 4096, 1, disk);			// Write new directory to disk				</a>
<a name="ln819">		printf(&quot;Complete\n&quot;);</a>
<a name="ln820">	}</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823"> </a>
<a name="ln824">/* EOF */</a>
</code></pre>
<div class="balloon" rel="552"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'disk' pointer was utilized before it was verified against nullptr. Check lines: 552, 575.</p></div>
<div class="balloon" rel="638"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'dir_copy' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="694"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'Directory' is cast to a more strictly aligned pointer type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>